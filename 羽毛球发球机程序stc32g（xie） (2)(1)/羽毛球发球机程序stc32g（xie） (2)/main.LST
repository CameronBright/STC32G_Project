C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE main.c XSMALL INTR2 BROWSE INCDIR(.\OLED;.\ti
                    -mer;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wave;.\Uart;.\SYN6288) DEBUG TABS(2) 

stmt  level    source

    1          /*
    2          program versions : 3.2
    3          
    4          增加了电机控制函数，此版本已能悬停
    5          
    6          modification: 2023/8/5 0:18
    7          
    8          modifier: Cameron Bright
    9          
   10          */
   11          #include "timer.h"   //定时器
   12          #include "oled.h"   //OLED函数
   13          #include "GPIO.h"   //GPIO
   14          #include "key.h"    //按键
   15          #include "Uart.h"   //串口
   16          #include "stdio.h"  //c标准库
   17          #include "motor.h"  //电机
   18          #include "LineFollower.h" //循迹模块
   19          #include "MPU6050.h"//mpu6050
   20          #include "MATH.H"   //数学运算模块
   21          
   22          //=================================
   23          
   24          #include "pwm_init.h"  //pwm
   25          #include "Wave.h"      //超声波
   26          
   27          //-------------------------------- system--------------------------------
   28          extern uint s_count;         //定时器计数
   29          extern uint delay_cnt;       //delay计数
   30          uint sys_led = 0;            //运行状态灯
   31          
   32          uint disp_delay;             //显示屏刷新延时计数
   33          uint motor_delay;            //电机函数刷新延时计数
   34          uint mpu6050_delay;          //mpu6050读取延时计数
   35          uint key_delay;              //案件延时刷新计数
   36          
   37          //----------------- motor(电机驱动和PID变量)--------------------------------
   38          //extern int dutyL;            //左边电机驱动pwm 周期1000
   39          //extern int dutyR;            //右
   40          
   41          //=======================================================================
   42          //******************************
   43          extern int Left_moto1     ;//左风机PWM
   44          extern int Right_moto2    ;//右
   45          extern int Forwar_dmoto1  ;//前
   46          extern int Backward_moto2 ;//后
   47          
   48          //======================================================================
   49          uchar motor_sw = 1;//电机开关
   50          
   51          struct pid_parameter positionPID; //PID参数
   52          int err_kp, err_ki, err_kd;   //误差值
   53          char line_inaccuracy; //循迹模块偏移量
   54          char old_line_inaccuracy;//上一次循迹模块的便宜量
   55          char old_position;    //上一次的数据
   56          
   57          //------------------MPU6050-----------------------------------------------
   58          //===================获取数据========================================================
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 2   

   59          
   60          
   61          extern float Angle_gx=0,Angle_gy=0,Angle_gz=0;    //由角速度计算的角速率(角度制)
   62          extern float Angle_ax=0,Angle_ay=0,Angle_az=0;    //由加速度计算的加速度(弧度制)
   63          float edata  Last_Angle_gx=0;         //外环PI输出量  上一次陀螺仪数据
   64          float edata Last_Angle_gy=0;
   65          
   66          int   edata g_x=0,g_y=0,g_z=0;          //陀螺仪矫正参数
   67          float edata a_x=0,a_y=0,a_z=0;              //角度矫正参数
   68          
   69          extern int X_Result=0,Y_Result=0,Z_Result=0;            //加入偏差值 
   70          
   71          unsigned char tp[16];   //读MP6050缓冲
   72          //-----------------other--------------------------------------------------
   73          uchar txbuf[20]; //串口发送缓存
   74          
   75          uchar oled_showtext[25]; //oled显示字符串
   76          
   77          void Disp_refresh(void);  //数码管显示函数
   78          void Motor_control(void); //电机控制函数
   79          void MPU6050_Read(void);  //陀螺仪数据采集
   80          void Key_Proc(void);
   81          
   82          //*****************按键***********//
   83          
   84          unsigned char key_old = 0;
   85          unsigned char key_value = 0;
   86          unsigned char key_Down = 0;
   87          unsigned char key_up = 0;
   88          
   89          extern unsigned int PWMB_CCR00;
   90          extern unsigned int PWMB_CCR01;
   91          extern unsigned int PWMB_CCR02;
   92          extern unsigned int PWMB_CCR03;
   93          
   94          extern unsigned int PWMB_CCA;
   95          
   96          //*******超声波*****//
   97          unsigned char Wave = 0;
   98          unsigned char Wave_Buff[20];
   99          extern unsigned long TF_Count;
  100          
  101          //循迹启动按键
  102          unsigned char T_S_B = 0;  //启动循迹按键
  103          unsigned char flag = 0;
  104          unsigned char flag_count = 0;
  105          unsigned char Tracking_value = 0;  //循迹值
  106          
  107          //*******流程*****//
  108          unsigned char scene = 0;
  109          bit wait_sw;
  110          unsigned int wait_tick = 0;
  111          
  112          void main()
  113          {
  114   1        GPIO_init();//GPIO初始化
  115   1        OLED_Init();//oled初始化
  116   1        OLED_ColorTurn(0);//0正常显示，1 反色显示
  117   1        OLED_DisplayTurn(0);//0正常显示 1 屏幕翻转显示
  118   1        OLED_Clear();//oled清屏
  119   1        
  120   1        Timer0Init();//定时器 0 初始化
  121   1        Timer1_Init(); //定时器 1 初始化
  122   1        Timer3_Init();//定时器 3 初始化
  123   1        
  124   1        Uart1_Init();// 串口1初始化
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 3   

  125   1        S1_S0=0; S1_S1=0;//串口1 选择P30 P31  
  126   1        
  127   1        P54RST=1;//复位初始化
  128   1        
  129   1        InitMPU6050(); //mpu6050初始化
  130   1        
  131   1        Motor_Init(); //电机初始化
  132   1        
  133   1        //PID参数
  134   1        positionPID.basicSpeed = 0;        //基础运动速度
  135   1        positionPID.kp = 600;
  136   1        positionPID.ki = 0;
  137   1        positionPID.kd = 50;
  138   1        
  139   1        PWMB_CCA = 1000; //浮空
  140   1        
  141   1        scene = 1;
  142   1          
  143   1        while(1)
  144   1        {
  145   2          Disp_refresh(); //数码管刷新函数
  146   2          MPU6050_Read(); //MPU6050控制函数
  147   2          Motor_control(); //电机控制函数
  148   2          Key_Proc();   //按键处理函数
  149   2          //Process(); //流程控制函数
  150   2        }
  151   1      }
  152          
  153          //定时器0中断函数
  154          void Timer0() interrupt 1
  155          {
  156   1        TF_Count += 1;
  157   1      }
  158          
  159          //-----------------定时器1中断-----------------------------------
  160          void timer1() interrupt 3       //100us中断一次
  161          {
  162   1        if(++disp_delay == 100) disp_delay = 0;       //显示屏刷新时间
  163   1        if(++motor_delay == 10) motor_delay = 0;      //电机控制刷新时间
  164   1        if(++mpu6050_delay == 50) mpu6050_delay = 0;  //mpu6050执行刷新时间
  165   1        if(++key_delay == 10) key_delay = 0;        //按键扫描刷新时间
  166   1        
  167   1        if(++sys_led >= 5000)                         
  168   1        {
  169   2          LED ^= 1;
  170   2          sys_led = 0;
  171   2        }
  172   1        
  173   1        if(delay_cnt > 0) //延时函数
  174   1          delay_cnt--;
  175   1        
  176   1      } 
  177          
  178          void Timer3_Isr(void) interrupt 19   //等待测试 1ms
  179          {
  180   1        if(flag == 1)         
  181   1        {
  182   2          flag_count++;
  183   2          if(flag_count > 100)
  184   2          {
  185   3            Tracking_value ++;   //循迹次数
  186   3            flag_count = 0;
  187   3            flag = 0;
  188   3          }
  189   2        }
  190   1      }
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 4   

  191          
  192          
  193          //-----------------按键处理-----------------------------------
  194          
  195          void Key_Proc(void)
  196          {
  197   1        if(key_delay) return; //100ms扫描一次按键
  198   1          key_delay = 1;
  199   1        
  200   1        key_value = Key_Rvalue();//读取按键按下的编号
  201   1        key_Down = key_value & (key_old ^ key_value); 
  202   1        key_up = ~key_value & (key_old ^ key_value);    
  203   1        key_old = key_value;  
  204   1        
  205   1        switch(key_Down)
  206   1        {
  207   2          case 1:
  208   2          PWMB_CCR00 += 50;
  209   2          if(PWMB_CCR00 > 1000)
  210   2            PWMB_CCR00 = 300;
  211   2          break;
  212   2          case 2:
  213   2          PWMB_CCR01 += 50; 
  214   2          if(PWMB_CCR01 > 1000)
  215   2            PWMB_CCR01 = 300;
  216   2          break;
  217   2          case 3:
  218   2          PWMB_CCR02 += 50;
  219   2          if(PWMB_CCR02 > 1000)
  220   2            PWMB_CCR02 = 300;
  221   2          break;
  222   2          case 4:
  223   2          PWMB_CCR03 += 50;
  224   2          if(PWMB_CCR03 > 1000)
  225   2            PWMB_CCR03 = 300;
  226   2          break;
  227   2        }
  228   1      }
  229          
  230          //-----------------显示屏函数-----------------------------------
  231          void Disp_refresh(void)
  232          {
  233   1        if(disp_delay) return; //10ms刷新一次屏幕
  234   1        disp_delay = 1;
  235   1        
  236   1        sprintf(oled_showtext,"Line:%d",line_inaccuracy); //循迹函数返回值
  237   1        OLED_Display_string_5x7(0,0,oled_showtext);
  238   1        
  239   1        sprintf(oled_showtext,"0:%03d 1:%03d ",PWMB_CCR00,PWMB_CCR01);
  240   1        OLED_Display_string_5x7(0,2,oled_showtext);
  241   1        
  242   1        sprintf(oled_showtext,"2:%03d 3:%03d ",PWMB_CCR02,PWMB_CCR03);
  243   1        OLED_Display_string_5x7(0,3,oled_showtext);
  244   1      
  245   1        sprintf(oled_showtext,"speed:%d",PWMB_CCA);
  246   1        OLED_Display_string_5x7(0,4,oled_showtext);
  247   1        
  248   1        
  249   1      //    sprintf(oled_showtext,"basic:%3d ",positionPID.basicSpeed);
  250   1      //  OLED_Display_string_5x7(0,4,oled_showtext);
  251   1      //  
  252   1      //    sprintf(oled_showtext,"Z:%5d  ",(int)Z_Result);
  253   1      //  OLED_Display_string_5x7(0,6,oled_showtext);
  254   1      //  
  255   1      //  
  256   1      //    sprintf(oled_showtext,"p:%4d,d:%4d",(int)positionPID.kp,(int)positionPID.kd);
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 5   

  257   1      //  OLED_Display_string_5x7(64,0,oled_showtext);
  258   1      //  
  259   1      //    sprintf(oled_showtext,"R: %5d ",(int)X_Result);
  260   1      //  OLED_Display_string_5x7(64,2,oled_showtext);
  261   1      //  
  262   1      //    sprintf(oled_showtext,"Y: %5d ",(int)Y_Result);
  263   1      //  OLED_Display_string_5x7(64,4,oled_showtext);
  264   1      //  
  265   1      //    sprintf(oled_showtext,"Y: %5d ",(int)flag_count);
  266   1      //  OLED_Display_string_5x7(64,7,oled_showtext);
  267   1      
  268   1      //    sprintf(oled_showtext,"P42 5: %5d ",PWMB_CCR00);
  269   1      //    OLED_Display_string_5x7(0,0,oled_showtext);
  270   1      //    sprintf(oled_showtext,"P41 6: %5d ",PWMB_CCR01);
  271   1      //    OLED_Display_string_5x7(0,2,oled_showtext);
  272   1      //    sprintf(oled_showtext,"P73 7: %5d ",PWMB_CCR02);
  273   1      //    OLED_Display_string_5x7(0,4,oled_showtext);
  274   1      //    sprintf(oled_showtext,"P70 8: %5d ",PWMB_CCR03);
  275   1      //    OLED_Display_string_5x7(0,6,oled_showtext);
  276   1      }
  277          
  278          //-------------陀螺仪控制函数----------------------------------------
  279          //相关变量
  280          
  281          //------------
  282          void MPU6050_Read(void)
  283          {
  284   1        if(mpu6050_delay) return; 
  285   1        mpu6050_delay = 1;
  286   1        
  287   1          //********************************************************************************************
  288   1          Read_MPU6050(tp); // 720us @24MHz
  289   1      
  290   1          Angle_ax = ((float)(((int *)&tp)[0])) / 8192.0; //加速度处理  结果单位是 +- g
  291   1          Angle_ay = ((float)(((int *)&tp)[1])) / 8192.0; //转换关系  8192 LSB/g, 1g对应读数8192
  292   1          Angle_az = ((float)(((int *)&tp)[2])) / 8192.0; //加速度量程 +-4g/S
  293   1          Last_Angle_gx = Angle_gx;   //储存上一次角速度数据
  294   1          Last_Angle_gy = Angle_gy;
  295   1          Angle_gx = ((float)(((int *)&tp)[4] - g_x)) / 65.5; //陀螺仪处理  结果单位是 +-度
  296   1          Angle_gy = ((float)(((int *)&tp)[5] - g_y)) / 65.5; //陀螺仪量程 +-500度/S, 1度/秒 对应读数 65.536
  297   1          Angle_gz = ((float)(((int *)&tp)[6] - g_z)) / 65.5; //转换关系65.5 LSB/度
  298   1      
  299   1      
  300   1          //**********************************X轴指向************************************************
  301   1          X_Result  = Angle_ax * 100 ;    //处理过的数值减去偏差值
  302   1          //**************Y轴指向**************************************************
  303   1          Y_Result  = Angle_ay * 100;   //处理过的数值减去偏差值
  304   1          //**************Z轴指向*****************************  
  305   1          Z_Result = Angle_az * 100;
  306   1      
  307   1      
  308   1          //==============================================================
  309   1              
  310   1      //    Uart1_sendbyte(0x03);
  311   1      //    Uart1_sendbyte(~0x03);
  312   1      //    
  313   1      //    Uart1_sendbyte((int)(X_Result*100));
  314   1      //    Uart1_sendbyte((int)(X_Result*100)>>8);
  315   1      //    Uart1_sendbyte((int)(Y_Result*100));
  316   1      //    Uart1_sendbyte((int)(Y_Result*100)>>8);
  317   1      //    Uart1_sendbyte((int)(Z_Result*100));
  318   1      //    Uart1_sendbyte((int)(Z_Result*100)>>8);
  319   1      //    
  320   1      //    Uart1_sendbyte(~0x03);
  321   1      //    Uart1_sendbyte(0x03);
  322   1             
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 6   

  323   1          //========================= 
  324   1      }
  325          
  326          //-----------------电机控制函数-------------------------------------
  327          void Motor_control(void)
  328          {
  329   1        if(motor_delay) return; //延时
  330   1        motor_delay = 1;
  331   1        
  332   1        if(scene == 1)
  333   1        {
  334   2          positionPID.basicSpeed = 0;
  335   2          sys_delay(60000);
  336   2          positionPID.basicSpeed = 600;
  337   2          scene = 0;
  338   2        }
  339   1          
  340   1        line_inaccuracy = ReadLine();//读取循线状态 2、1、0、-1、-2
  341   1        
  342   1        if(line_inaccuracy > 2 || line_inaccuracy < -2)
  343   1        {
  344   2          if(line_inaccuracy == 3)
  345   2            line_inaccuracy = old_position;
  346   2        }
  347   1        else 
  348   1        {
  349   2          old_position = line_inaccuracy;//记录上一次的位置
  350   2        }
  351   1        
  352   1        if(!line_inaccuracy)
  353   1        {
  354   2          PWMB_CCR02 = positionPID.basicSpeed;
  355   2          PWMB_CCR00 = PWMB_CCR01 = 0;
  356   2        }
  357   1        else if(line_inaccuracy > 0)
  358   1        {
  359   2          PWMB_CCR00 = (positionPID.kp * line_inaccuracy) + (positionPID.kd * old_line_inaccuracy);
  360   2          PWMB_CCR01 = 0;
  361   2          
  362   2        }
  363   1        else if(line_inaccuracy < 0)
  364   1        {
  365   2          PWMB_CCR01 = (positionPID.kp * -line_inaccuracy) + (positionPID.kd * -old_line_inaccuracy)+200;
  366   2          PWMB_CCR00 = 0;
  367   2        }
  368   1        
  369   1        Update_PWM(PWMB_CCR00,PWMB_CCR01,PWMB_CCR02,PWMB_CCR03,PWMB_CCA);
  370   1        old_line_inaccuracy = line_inaccuracy;
  371   1      }
  372          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1246     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       183     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
C251 COMPILER V5.60.0,  main                                                               05/08/23  06:39:32  PAGE 7   

  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       238     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C251 COMPILER V5.60.0,  pwm_init                                                           05/08/23  06:06:32  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pwm_init
OBJECT MODULE PLACED IN pwm_init.obj
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE PWM\pwm_init.c XSMALL INTR2 BROWSE INCDIR(.\O
                    -LED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wave;.\Uart;.\SYN6288) DEBUG PR
                    -INT(.\pwm_init.lst) TABS(2) OBJECT(pwm_init.obj) 

stmt  level    source

    1          #include "pwm_init.h"
    2          
    3          int dutyL = 0;
    4          int dutyR = 0;
    5          
    6          extern int Left_moto1     = 0;//左风机PWM
    7          extern int Right_moto2    = 0;//右
    8          extern int Forwar_dmoto1  = 0;//前
    9          extern int Backward_moto2 = 0;//后
   10          
   11          unsigned int PWMB_CCR00 = 0;  //P00
   12          unsigned int PWMB_CCR01 = 0;  //P01
   13          unsigned int PWMB_CCR02 = 0;  //P0
   14          unsigned int PWMB_CCR03 = 0;  //P03
   15          
   16          unsigned int PWMB_CCA = 0;
   17          
   18          void PWM_Config(void)
   19          {
   20   1        PWMA_PS = 0xAA;             //PWMA:P60 P62 P64 P66
   21   1        
   22   1        PWMA_PSCRH = (uint)(PWM_PSC >> 8);
   23   1        PWMA_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   24   1        
   25   1        
   26   1        PWMA_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   27   1        PWMA_CCER2 = 0x00; 
   28   1        PWMA_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   29   1        PWMA_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   30   1        PWMA_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   31   1        PWMA_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   32   1        PWMA_CCER1 = 0x33; // 使能 CC1 CC2通道
   33   1        PWMA_CCER2 = 0x33; // 使能 CC3 CC4通道
   34   1        
   35   1        
   36   1        PWMA_CCR1H = (uint)(PWMB_CCA >> 8); // 设置CC1占空比时间 占空比2.5%
   37   1        PWMA_CCR1L = (uint)(PWMB_CCA); 
   38   1        
   39   1        PWMA_CCR2H = (uint)(PWMB_CCA >> 8); // 设置CC2占空比时间 占空比2.5%
   40   1        PWMA_CCR2L = (uint)(PWMB_CCA); 
   41   1        
   42   1        PWMA_CCR3H = (uint)(PWMB_CCA >> 8); // 设置CC3占空比时间 占空比2.5%
   43   1        PWMA_CCR3L = (uint)(PWMB_CCA); 
   44   1        
   45   1        PWMA_CCR4H = (uint)(PWMB_CCA >> 8); // 设置CC4占空比时间 占空比2.5%
   46   1        PWMA_CCR4L = (uint)(PWMB_CCA); 
   47   1        
   48   1      
   49   1        PWMA_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   50   1        PWMA_ARRL = (uint)(PWM_PERIOD); 
   51   1      
   52   1        PWMA_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   53   1        PWMA_BKR = 0x80;                    // 使能主输出
   54   1      
   55   1        PWMA_CR1 = 0x01;                    // 启动PWM定时器  
   56   1        
   57   1        
C251 COMPILER V5.60.0,  pwm_init                                                           05/08/23  06:06:32  PAGE 2   

   58   1        //PWMB
   59   1        PWMB_PS = 0xAA;                   //PWMB:P00 P01 P02 P03
   60   1        
   61   1        PWMB_PSCRH = (uint)(PWM_PSC >> 8);
   62   1        PWMB_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   63   1        
   64   1        
   65   1        PWMB_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   66   1        PWMB_CCER2 = 0x00; 
   67   1        
   68   1        PWMB_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   69   1        PWMB_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   70   1        PWMB_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   71   1        PWMB_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   72   1        PWMB_CCER1 = 0x33; // 使能 CC1 CC2通道
   73   1        PWMB_CCER2 = 0x33; // 使能 CC3 CC4通道
   74   1        
   75   1        
   76   1        PWMB_CCR5H = (uint)(PWMB_CCR00 >> 8); // 设置CC5占空比时间 占空比2.5%
   77   1        PWMB_CCR5L = (uint)(PWMB_CCR00); 
   78   1        
   79   1        PWMB_CCR6H = (uint)(PWMB_CCR01 >> 8); // 设置CC6占空比时间 占空比2.5%
   80   1        PWMB_CCR6L = (uint)(PWMB_CCR01); 
   81   1      
   82   1        PWMB_CCR7H = (uint)(PWMB_CCR02 >> 8); // 设置CC7占空比时间 占空比2.5%
   83   1        PWMB_CCR7L = (uint)(PWMB_CCR02); 
   84   1        
   85   1        PWMB_CCR8H = (uint)(PWMB_CCR03 >> 8); // 设置CC8占空比时间 占空比2.5%
   86   1        PWMB_CCR8L = (uint)(PWMB_CCR03); 
   87   1        
   88   1      
   89   1        PWMB_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   90   1        PWMB_ARRL = (uint)(PWM_PERIOD); 
   91   1      
   92   1        PWMB_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   93   1        PWMB_BKR = 0x80;                    // 使能主输出
   94   1      
   95   1        PWMB_CR1 = 0x01;                    // 启动PWM定时器    
   96   1      }
   97          
   98          /**************************************************************************
   99          函数功能：限制PWM赋值 
  100          入口参数：无
  101          返回  值：无
  102          **************************************************************************/
  103          //void Xianfu_Pwm(void)
  104          //{
  105          //   //===PWM满幅是100 限制在95
  106          //    if(Left_moto1<-950 ) Left_moto1=-950 ;
  107          //    if(Left_moto1>950 )  Left_moto1=950 ;
  108          //    if(Right_moto2<-950 ) Right_moto2=-950 ;
  109          //    if(Right_moto2>950 )  Right_moto2=950 ;
  110          //    if(Forwar_dmoto1<-950 ) Forwar_dmoto1=-950 ;
  111          //    if(Forwar_dmoto1>950 )  Forwar_dmoto1=950 ;
  112          //    if(Backward_moto2<-950 ) Backward_moto2=-950 ;
  113          //    if(Backward_moto2>950 )  Backward_moto2=950 ;
  114          //}
  115          
  116          //更新PWM 0
  117          void Update_Pwm0(unsigned int Duty0)
  118          {
  119   1        PWMB_CCR5H = (uint)(Duty0 >> 8); // 设置CC5占空比时间 占空比2.5%
  120   1        PWMB_CCR5L = (uint)(Duty0); 
  121   1      }
  122          //更新PWM 1
  123          void Update_Pwm1(unsigned int Duty1)
C251 COMPILER V5.60.0,  pwm_init                                                           05/08/23  06:06:32  PAGE 3   

  124          {
  125   1        PWMB_CCR6H = (uint)(Duty1 >> 8); // 设置CC6占空比时间 占空比2.5%
  126   1        PWMB_CCR6L = (uint)(Duty1);   
  127   1      }
  128          //更新PWM 2
  129          void Update_Pwm2(unsigned int Duty2)
  130          {
  131   1        PWMB_CCR7H = (uint)(Duty2 >> 8); // 设置CC7占空比时间 占空比2.5%
  132   1        PWMB_CCR7L = (uint)(Duty2);   
  133   1      }
  134          //更新PWM 3
  135          void Update_Pwm3(unsigned int Duty3)
  136          {
  137   1        PWMB_CCR8H = (uint)(Duty3 >> 8); // 设置CC8占空比时间 占空比2.5%
  138   1        PWMB_CCR8L = (uint)(Duty3);   
  139   1      }
  140          //更新PWM 4 (往下吹风的电机)
  141          void Update_Pwm4(unsigned int Duty4)
  142          {
  143   1        PWMA_CCR3H = (uint)(Duty4 >> 8); // 设置CC3占空比时间 占空比2.5%
  144   1        PWMA_CCR3L = (uint)(Duty4); 
  145   1      }
  146          
  147          //void Set_FBPwm(int Forwar_dmoto1,int Backward_moto2)    //更新前后风机占空比
  148          //{
  149          //  
  150          //  
  151          //  if(Forwar_dmoto1<0)   
  152          //  CIN2=1,     CIN1=0;  //如果小于零就是反转  先变换电平  motol
  153          //  else
  154          //  CIN2=0,     CIN1=1;
  155          //  
  156          //  
  157          //  PWMA_CCR3H = (myabs(Forwar_dmoto1) >> 8);  
  158          //  PWMA_CCR3L = (myabs(Forwar_dmoto1));
  159          
  160          //  
  161          //  if(Forwar_dmoto1<0)   
  162          //  DIN1=0,     DIN2=1;
  163          //  
  164          //  else
  165          //  DIN1=1,     DIN2=0;
  166          //  
  167          //  PWMA_CCR4H = (myabs(Backward_moto2)>> 8);  
  168          //  PWMA_CCR4L = (myabs(Backward_moto2));
  169          //  
  170          //  
  171          //}
  172          
  173          void Update_PWM(int pwm0,int pwm1,int pwm2,int pwm3,int pwm4)
  174          {
  175   1        if(pwm0 > 1000)
  176   1          pwm0 = 1000;
  177   1        if(pwm1 > 1000)
  178   1          pwm1 = 1000;
  179   1        if(pwm2 > 1000)
  180   1          pwm2 = 1000;
  181   1        if(pwm3 > 1000)
  182   1          pwm3 = 1000;
  183   1        if(pwm4 > 1000)
  184   1          pwm4 = 1000;
  185   1        
  186   1        Update_Pwm0(pwm0);
  187   1        Update_Pwm1(pwm1);
  188   1        Update_Pwm2(pwm2);
  189   1        Update_Pwm3(pwm3);
C251 COMPILER V5.60.0,  pwm_init                                                           05/08/23  06:06:32  PAGE 4   

  190   1        
  191   1        Update_Pwm4(pwm4);
  192   1      }
  193            
  194          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       617     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        22          4
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        66     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

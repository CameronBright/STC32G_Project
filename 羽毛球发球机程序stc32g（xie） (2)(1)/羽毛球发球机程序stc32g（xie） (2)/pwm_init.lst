C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  20:55:20  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pwm_init
OBJECT MODULE PLACED IN pwm_init.obj
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE PWM\pwm_init.c XSMALL INTR2 WARNINGLEVEL(1) B
                    -ROWSE INCDIR(.\OLED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wave;.\Uart;.\S
                    -YN6288) DEBUG PRINT(.\pwm_init.lst) TABS(2) OBJECT(pwm_init.obj) 

stmt  level    source

    1          #include "pwm_init.h"
    2          
    3          int dutyL = 0;
    4          int dutyR = 0;
    5          
    6          extern int Left_moto1     = 0;//左风机PWM
    7          extern int Right_moto2    = 0;//右
    8          extern int Forwar_dmoto1  = 0;//前
    9          extern int Backward_moto2 = 0;//后
   10          
   11          unsigned int PWMB_CCR5 = 300;  //P00
   12          unsigned int PWMB_CCR6 = 300;  //P01
   13          unsigned int PWMB_CCR7 = 300;  //P0
   14          unsigned int PWMB_CCR8 = 300;  //P03
   15          
   16          unsigned int PWMB_CCA = 0;
   17          
   18          void PWM_Config(void)
   19          {
   20   1        PWMA_PS = 0xAA;             //PWMA:P60 P62 P64 P66
   21   1        
   22   1        PWMA_PSCRH = (uint)(PWM_PSC >> 8);
   23   1        PWMA_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   24   1        
   25   1        
   26   1        PWMA_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   27   1        PWMA_CCER2 = 0x00; 
   28   1        PWMA_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   29   1        PWMA_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   30   1        PWMA_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   31   1        PWMA_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   32   1        PWMA_CCER1 = 0x33; // 使能 CC1 CC2通道
   33   1        PWMA_CCER2 = 0x33; // 使能 CC3 CC4通道
   34   1        
   35   1        
   36   1        PWMA_CCR1H = (uint)(PWMB_CCA >> 8); // 设置CC1占空比时间 占空比2.5%
   37   1        PWMA_CCR1L = (uint)(PWMB_CCA); 
   38   1        
   39   1        PWMA_CCR2H = (uint)(PWMB_CCA >> 8); // 设置CC2占空比时间 占空比2.5%
   40   1        PWMA_CCR2L = (uint)(PWMB_CCA); 
   41   1        
   42   1        PWMA_CCR3H = (uint)(PWMB_CCA >> 8); // 设置CC3占空比时间 占空比2.5%
   43   1        PWMA_CCR3L = (uint)(PWMB_CCA); 
   44   1        
   45   1        PWMA_CCR4H = (uint)(PWMB_CCA >> 8); // 设置CC4占空比时间 占空比2.5%
   46   1        PWMA_CCR4L = (uint)(PWMB_CCA); 
   47   1        
   48   1      
   49   1        PWMA_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   50   1        PWMA_ARRL = (uint)(PWM_PERIOD); 
   51   1      
   52   1        PWMA_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   53   1        PWMA_BKR = 0x80;                    // 使能主输出
   54   1      
   55   1        PWMA_CR1 = 0x01;                    // 启动PWM定时器  
   56   1        
   57   1        
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  20:55:20  PAGE 2   

   58   1        //PWMB
   59   1        PWMB_PS = 0xAA;                   //PWMB:P00 P01 P02 P03
   60   1        
   61   1        PWMB_PSCRH = (uint)(PWM_PSC >> 8);
   62   1        PWMB_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   63   1        
   64   1        
   65   1        PWMB_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   66   1        PWMB_CCER2 = 0x00; 
   67   1        
   68   1        PWMB_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   69   1        PWMB_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   70   1        PWMB_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   71   1        PWMB_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   72   1        PWMB_CCER1 = 0x33; // 使能 CC1 CC2通道
   73   1        PWMB_CCER2 = 0x33; // 使能 CC3 CC4通道
   74   1        
   75   1        
   76   1        PWMB_CCR5H = (uint)(PWMB_CCR5 >> 8); // 设置CC5占空比时间 占空比2.5%
   77   1        PWMB_CCR5L = (uint)(PWMB_CCR5); 
   78   1        
   79   1        PWMB_CCR6H = (uint)(PWMB_CCR6 >> 8); // 设置CC6占空比时间 占空比2.5%
   80   1        PWMB_CCR6L = (uint)(PWMB_CCR6); 
   81   1      
   82   1        PWMB_CCR7H = (uint)(PWMB_CCR7 >> 8); // 设置CC7占空比时间 占空比2.5%
   83   1        PWMB_CCR7L = (uint)(PWMB_CCR7); 
   84   1        
   85   1        PWMB_CCR8H = (uint)(PWMB_CCR8 >> 8); // 设置CC8占空比时间 占空比2.5%
   86   1        PWMB_CCR8L = (uint)(PWMB_CCR8); 
   87   1        
   88   1      
   89   1        PWMB_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   90   1        PWMB_ARRL = (uint)(PWM_PERIOD); 
   91   1      
   92   1        PWMB_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   93   1        PWMB_BKR = 0x80;                    // 使能主输出
   94   1      
   95   1        PWMB_CR1 = 0x01;                    // 启动PWM定时器    
   96   1      }
   97          
   98          
   99          //更新PWMB 5
  100          void Update_5(unsigned int Duty1)
  101          {
  102   1        PWMB_CCR5H = (uint)(Duty1 >> 8); // 设置CC5占空比时间 占空比2.5%
  103   1        PWMB_CCR5L = (uint)(Duty1); 
  104   1      }
  105          //更新PWMB 6
  106          void Update_6(unsigned int Duty2)
  107          {
  108   1        PWMB_CCR6H = (uint)(Duty2 >> 8); // 设置CC6占空比时间 占空比2.5%
  109   1        PWMB_CCR6L = (uint)(Duty2);   
  110   1      }
  111          //更新PWMB 7
  112          void Update_7(unsigned int Duty3)
  113          {
  114   1        PWMB_CCR7H = (uint)(Duty3 >> 8); // 设置CC7占空比时间 占空比2.5%
  115   1        PWMB_CCR7L = (uint)(Duty3);   
  116   1      }
  117          //更新PWMB 8
  118          void Update_8(unsigned int Duty4)
  119          {
  120   1        PWMB_CCR8H = (uint)(Duty4 >> 8); // 设置CC8占空比时间 占空比2.5%
  121   1        PWMB_CCR8L = (uint)(Duty4);   
  122   1      }
  123          
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  20:55:20  PAGE 3   

  124          /**************************************************************************
  125          函数功能：绝对值函数
  126          入口参数：int
  127          返回  值：unsigned int
  128          目    的：对PWM进行绝对值处理
  129          **************************************************************************/
  130          int myabs(int a)
  131          {        
  132   1          int temp;
  133   1          if(a<0)  temp=-a;  
  134   1          else temp=a;
  135   1          return temp;
  136   1      }
  137          
  138          /**************************************************************************
  139          函数功能：限制PWM赋值 
  140          入口参数：无
  141          返回  值：无
  142          **************************************************************************/
  143          void Xianfu_Pwm(void)
  144          {
  145   1         //===PWM满幅是100 限制在95
  146   1          if(Left_moto1<-950 ) Left_moto1=-950 ;
  147   1          if(Left_moto1>950 )  Left_moto1=950 ;
  148   1          if(Right_moto2<-950 ) Right_moto2=-950 ;
  149   1          if(Right_moto2>950 )  Right_moto2=950 ;
  150   1          if(Forwar_dmoto1<-950 ) Forwar_dmoto1=-950 ;
  151   1          if(Forwar_dmoto1>950 )  Forwar_dmoto1=950 ;
  152   1          if(Backward_moto2<-950 ) Backward_moto2=-950 ;
  153   1          if(Backward_moto2>950 )  Backward_moto2=950 ;
  154   1      }
  155          
  156          /**************************************************************************
  157          函数功能：检测异常关闭电机
  158          入口参数：检测异常参数
  159          返回  值：无
  160          **************************************************************************/
  161          //void Turn_Off(float angle)
  162          //{
  163          //    if(angle<-40||angle>40)  //电池电压低于11.1V关闭电机
  164          //    {                                    //===倾角大于40度关闭电机                                       
  165          //        moto1=0;
  166          //        moto2=0;
  167          //    }   
  168          //}
  169          
  170          /**************************************************************************
  171          函数功能：赋值给PWM寄存器
  172          入口参数：左轮PWM、右轮PWM
  173          返回  值：无
  174          **************************************************************************/
  175          
  176          void Set_LRPwm(int Left_moto1,int Right_moto2)    //更新左右风机占空比
  177          {
  178   1        
  179   1        
  180   1        if(Left_moto1<0)    
  181   1        AIN2=1,     AIN1=0;  //如果小于零就是反转  先变换电平  motol
  182   1        else
  183   1        AIN2=0,     AIN1=1;
  184   1        
  185   1        
  186   1        PWMA_CCR1H = (myabs(Left_moto1) >> 8);  
  187   1        PWMA_CCR1L = (myabs(Left_moto1));
  188   1      
  189   1        
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  20:55:20  PAGE 4   

  190   1        if(Right_moto2<0)   
  191   1        BIN1=0,     BIN2=1;
  192   1        
  193   1        else
  194   1        BIN1=1,     BIN2=0;
  195   1        
  196   1        PWMA_CCR2H = (myabs(Right_moto2)>> 8);  
  197   1        PWMA_CCR2L = (myabs(Right_moto2));
  198   1        
  199   1        
  200   1      }
  201          
  202          void Set_FBPwm(int Forwar_dmoto1,int Backward_moto2)    //更新前后风机占空比
  203          {
  204   1        
  205   1        
  206   1        if(Forwar_dmoto1<0)   
  207   1        CIN2=1,     CIN1=0;  //如果小于零就是反转  先变换电平  motol
  208   1        else
  209   1        CIN2=0,     CIN1=1;
  210   1        
  211   1        
  212   1        PWMA_CCR3H = (myabs(Forwar_dmoto1) >> 8);  
  213   1        PWMA_CCR3L = (myabs(Forwar_dmoto1));
  214   1      
  215   1        
  216   1        if(Forwar_dmoto1<0)   
  217   1        DIN1=0,     DIN2=1;
  218   1        
  219   1        else
  220   1        DIN1=1,     DIN2=0;
  221   1        
  222   1        PWMA_CCR4H = (myabs(Backward_moto2)>> 8);  
  223   1        PWMA_CCR4L = (myabs(Backward_moto2));
  224   1        
  225   1        
  226   1      }
  227          
  228          void Update_duty(uchar sw,int PWMR,int PWML)                    //更新占空比函数
  229          {
  230   1        
  231   1        if(!sw)
  232   1        {
  233   2          PWML = 0;
  234   2          PWMR = 0;
  235   2        }
  236   1        
  237   1        if(PWMR < 0)
  238   1        {
  239   2          PWMR = -PWMR;
  240   2          MotorR_Reverse();
*** WARNING C140 IN LINE 240 OF PWM\pwm_init.c: 'MotorR_Reverse' undefined; assuming 'extern int MotorR_Reverse()'
  241   2        }
  242   1        else 
  243   1          MotorR_Forward();
*** WARNING C140 IN LINE 243 OF PWM\pwm_init.c: 'MotorR_Forward' undefined; assuming 'extern int MotorR_Forward()'
  244   1          
  245   1        if(PWML < 0)
  246   1        {
  247   2          PWML = -PWML;
  248   2          MotorL_Reverse();
*** WARNING C140 IN LINE 248 OF PWM\pwm_init.c: 'MotorL_Reverse' undefined; assuming 'extern int MotorL_Reverse()'
  249   2        }
  250   1        else 
  251   1          MotorL_Forward();
*** WARNING C140 IN LINE 251 OF PWM\pwm_init.c: 'MotorL_Forward' undefined; assuming 'extern int MotorL_Forward()'
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  20:55:20  PAGE 5   

  252   1          
  253   1        
  254   1        PWMA_CCR1H  = (uchar)(PWML >> 8);  
  255   1        PWMA_CCR1L = PWML;                //调整占空比
  256   1          
  257   1        PWMA_CCR2H = (uchar)(PWMR >> 8); 
  258   1        PWMA_CCR2L = PWMR;  
  259   1      }
  260          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       969     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        22     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        66     ------
End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)

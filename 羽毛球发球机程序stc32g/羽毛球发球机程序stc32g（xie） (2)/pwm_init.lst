C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  12:54:06  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pwm_init
OBJECT MODULE PLACED IN pwm_init.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE PWM\pwm_init.c XSMALL INTR2 WARNINGLEVEL(1) BROWSE INCDIR(.\OLED;.\tim
                    -er;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wave;.\Uart;.\SYN6288) DEBUG PRINT(.\pwm
                    -_init.lst) TABS(2) OBJECT(pwm_init.obj) 

stmt  level    source

    1          #include "pwm_init.h"
    2          
    3          
    4          
    5          int dutyL = 0;
    6          int dutyR = 0;
    7          
    8          extern int Left_moto1     = 0;//左风机PWM
    9          extern int Right_moto2    = 0;//右
   10          extern int Forwar_dmoto1  = 0;//前
   11          extern int Backward_moto2 = 0;//后
   12          
   13          
   14          void PWM_Config(void)
   15          {
   16   1        PWMA_PS = 0xAA;             //PWMA:P60 P62 P64 P66
   17   1        
   18   1        PWMA_PSCRH = (uint)(PWM_PSC >> 8);
   19   1        PWMA_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   20   1        
   21   1        
   22   1        PWMA_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   23   1        PWMA_CCER2 = 0x00; 
   24   1        PWMA_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   25   1        PWMA_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   26   1        PWMA_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   27   1        PWMA_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   28   1        PWMA_CCER1 = 0x33; // 使能 CC1 CC2通道
   29   1        PWMA_CCER2 = 0x33; // 使能 CC3 CC4通道
   30   1        
   31   1        
   32   1        PWMA_CCR1H = (uint)(1000 >> 8); // 设置CC1占空比时间 占空比2.5%
   33   1        PWMA_CCR1L = (uint)(1000); 
   34   1        
   35   1        PWMA_CCR2H = (uint)(1000 >> 8); // 设置CC2占空比时间 占空比2.5%
   36   1        PWMA_CCR2L = (uint)(1000); 
   37   1        
   38   1        PWMA_CCR3H = (uint)(1000 >> 8); // 设置CC3占空比时间 占空比2.5%
   39   1        PWMA_CCR3L = (uint)(1000); 
   40   1        
   41   1        PWMA_CCR4H = (uint)(1000 >> 8); // 设置CC4占空比时间 占空比2.5%
   42   1        PWMA_CCR4L = (uint)(1000); 
   43   1        
   44   1      
   45   1        PWMA_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   46   1        PWMA_ARRL = (uint)(PWM_PERIOD); 
   47   1      
   48   1        PWMA_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   49   1        PWMA_BKR = 0x80;                    // 使能主输出
   50   1      
   51   1        PWMA_CR1 = 0x01;                    // 启动PWM定时器  
   52   1        
   53   1        
   54   1        //PWMB
   55   1        PWMB_PS = 0xAA;                   //PWMB:P00 P01 P02 P03
   56   1        
   57   1        PWMB_PSCRH = (uint)(PWM_PSC >> 8);
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  12:54:06  PAGE 2   

   58   1        PWMB_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   59   1        
   60   1        
   61   1        PWMB_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   62   1        PWMB_CCER2 = 0x00; 
   63   1        
   64   1        PWMB_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   65   1        PWMB_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   66   1        PWMB_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   67   1        PWMB_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   68   1        PWMB_CCER1 = 0x33; // 使能 CC1 CC2通道
   69   1        PWMB_CCER2 = 0x33; // 使能 CC3 CC4通道
   70   1        
   71   1        
   72   1        PWMB_CCR5H = (uint)(500 >> 8); // 设置CC1占空比时间 占空比2.5%
   73   1        PWMB_CCR5L = (uint)(500); 
   74   1        
   75   1        PWMB_CCR6H = (uint)(500 >> 8); // 设置CC2占空比时间 占空比2.5%
   76   1        PWMB_CCR6L = (uint)(500); 
   77   1      
   78   1        PWMB_CCR7H = (uint)(500 >> 8); // 设置CC3占空比时间 占空比2.5%
   79   1        PWMB_CCR7L = (uint)(500); 
   80   1        
   81   1        PWMB_CCR8H = (uint)(500 >> 8); // 设置CC4占空比时间 占空比2.5%
   82   1        PWMB_CCR8L = (uint)(500); 
   83   1        
   84   1      
   85   1        PWMB_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   86   1        PWMB_ARRL = (uint)(PWM_PERIOD); 
   87   1      
   88   1        PWMB_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   89   1        PWMB_BKR = 0x80;                    // 使能主输出
   90   1      
   91   1        PWMB_CR1 = 0x01;                    // 启动PWM定时器    
   92   1      }
   93          
   94          
   95          /**************************************************************************
   96          函数功能：绝对值函数
   97          入口参数：int
   98          返回  值：unsigned int
   99          目    的：对PWM进行绝对值处理
  100          **************************************************************************/
  101          int myabs(int a)
  102          {        
  103   1          int temp;
  104   1          if(a<0)  temp=-a;  
  105   1          else temp=a;
  106   1          return temp;
  107   1      }
  108          
  109          /**************************************************************************
  110          函数功能：限制PWM赋值 
  111          入口参数：无
  112          返回  值：无
  113          **************************************************************************/
  114          void Xianfu_Pwm(void)
  115          {
  116   1         //===PWM满幅是100 限制在95
  117   1          if(Left_moto1<-950 ) Left_moto1=-950 ;
  118   1          if(Left_moto1>950 )  Left_moto1=950 ;
  119   1          if(Right_moto2<-950 ) Right_moto2=-950 ;
  120   1          if(Right_moto2>950 )  Right_moto2=950 ;
  121   1          if(Forwar_dmoto1<-950 ) Forwar_dmoto1=-950 ;
  122   1          if(Forwar_dmoto1>950 )  Forwar_dmoto1=950 ;
  123   1          if(Backward_moto2<-950 ) Backward_moto2=-950 ;
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  12:54:06  PAGE 3   

  124   1          if(Backward_moto2>950 )  Backward_moto2=950 ;
  125   1      }
  126          
  127          /**************************************************************************
  128          函数功能：检测异常关闭电机
  129          入口参数：检测异常参数
  130          返回  值：无
  131          **************************************************************************/
  132          //void Turn_Off(float angle)
  133          //{
  134          //    if(angle<-40||angle>40)  //电池电压低于11.1V关闭电机
  135          //    {                                    //===倾角大于40度关闭电机                                       
  136          //        moto1=0;
  137          //        moto2=0;
  138          //    }   
  139          //}
  140          
  141          /**************************************************************************
  142          函数功能：赋值给PWM寄存器
  143          入口参数：左轮PWM、右轮PWM
  144          返回  值：无
  145          **************************************************************************/
  146          
  147          void Set_LRPwm(int Left_moto1,int Right_moto2)    //更新左右风机占空比
  148          {
  149   1        
  150   1        
  151   1        if(Left_moto1<0)    
  152   1        AIN2=1,     AIN1=0;  //如果小于零就是反转  先变换电平  motol
  153   1        else
  154   1        AIN2=0,     AIN1=1;
  155   1        
  156   1        
  157   1        PWMA_CCR1H = (myabs(Left_moto1) >> 8);  
  158   1        PWMA_CCR1L = (myabs(Left_moto1));
  159   1      
  160   1        
  161   1        if(Right_moto2<0)   
  162   1        BIN1=0,     BIN2=1;
  163   1        
  164   1        else
  165   1        BIN1=1,     BIN2=0;
  166   1        
  167   1        PWMA_CCR2H = (myabs(Right_moto2)>> 8);  
  168   1        PWMA_CCR2L = (myabs(Right_moto2));
  169   1        
  170   1        
  171   1      }
  172          
  173          
  174          void Set_FBPwm(int Forwar_dmoto1,int Backward_moto2)    //更新前后风机占空比
  175          {
  176   1        
  177   1        
  178   1        if(Forwar_dmoto1<0)   
  179   1        CIN2=1,     CIN1=0;  //如果小于零就是反转  先变换电平  motol
  180   1        else
  181   1        CIN2=0,     CIN1=1;
  182   1        
  183   1        
  184   1        PWMA_CCR3H = (myabs(Forwar_dmoto1) >> 8);  
  185   1        PWMA_CCR3L = (myabs(Forwar_dmoto1));
  186   1      
  187   1        
  188   1        if(Forwar_dmoto1<0)   
  189   1        DIN1=0,     DIN2=1;
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  12:54:06  PAGE 4   

  190   1        
  191   1        else
  192   1        DIN1=1,     DIN2=0;
  193   1        
  194   1        PWMA_CCR4H = (myabs(Backward_moto2)>> 8);  
  195   1        PWMA_CCR4L = (myabs(Backward_moto2));
  196   1        
  197   1        
  198   1      }
  199          
  200          void Update_duty(uchar sw,int PWMR,int PWML)                    //更新占空比函数
  201          {
  202   1        
  203   1        if(!sw)
  204   1        {
  205   2          PWML = 0;
  206   2          PWMR = 0;
  207   2        }
  208   1        
  209   1        if(PWMR < 0)
  210   1        {
  211   2          PWMR = -PWMR;
  212   2          MotorR_Reverse();
*** WARNING C140 IN LINE 212 OF PWM\pwm_init.c: 'MotorR_Reverse' undefined; assuming 'extern int MotorR_Reverse()'
  213   2        }
  214   1        else 
  215   1          MotorR_Forward();
*** WARNING C140 IN LINE 215 OF PWM\pwm_init.c: 'MotorR_Forward' undefined; assuming 'extern int MotorR_Forward()'
  216   1          
  217   1        if(PWML < 0)
  218   1        {
  219   2          PWML = -PWML;
  220   2          MotorL_Reverse();
*** WARNING C140 IN LINE 220 OF PWM\pwm_init.c: 'MotorL_Reverse' undefined; assuming 'extern int MotorL_Reverse()'
  221   2        }
  222   1        else 
  223   1          MotorL_Forward();
*** WARNING C140 IN LINE 223 OF PWM\pwm_init.c: 'MotorL_Forward' undefined; assuming 'extern int MotorL_Forward()'
  224   1          
  225   1        
  226   1        PWMA_CCR1H  = (uchar)(PWML >> 8);  
  227   1        PWMA_CCR1L = PWML;                //调整占空比
  228   1          
  229   1        PWMA_CCR2H = (uchar)(PWMR >> 8); 
  230   1        PWMA_CCR2L = PWMR;  
  231   1      }
  232          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       891     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        12     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        36     ------
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  12:54:06  PAGE 5   

End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)

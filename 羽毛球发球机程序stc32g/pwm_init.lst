C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  19:36:15  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE pwm_init
OBJECT MODULE PLACED IN pwm_init.obj
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE PWM\pwm_init.c XSMALL INTR2 WARNINGLEVEL(1) B
                    -ROWSE INCDIR(.\OLED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wave;.\Uart;.\S
                    -YN6288) DEBUG PRINT(.\pwm_init.lst) TABS(2) OBJECT(pwm_init.obj) 

stmt  level    source

    1          #include "pwm_init.h"
    2          
    3          
    4          
    5          int dutyL = 0;
    6          int dutyR = 0;
    7          
    8          extern int Left_moto1     = 0;//左风机PWM
    9          extern int Right_moto2    = 0;//右
   10          extern int Forwar_dmoto1  = 0;//前
   11          extern int Backward_moto2 = 0;//后
   12          
   13          unsigned int PWMB_CCR5 = 300;
   14          unsigned int PWMB_CCR6 = 300;
   15          unsigned int PWMB_CCR7 = 300;
   16          unsigned int PWMB_CCR8 = 300;
   17          
   18          unsigned int PWMB_CCA = 1000;
   19          void PWM_Config(void)
   20          {
   21   1        PWMA_PS = 0xAA;             //PWMA:P60 P62 P64 P66
   22   1        
   23   1        PWMA_PSCRH = (uint)(PWM_PSC >> 8);
   24   1        PWMA_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   25   1        
   26   1        
   27   1        PWMA_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   28   1        PWMA_CCER2 = 0x00; 
   29   1        PWMA_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   30   1        PWMA_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   31   1        PWMA_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   32   1        PWMA_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   33   1        PWMA_CCER1 = 0x33; // 使能 CC1 CC2通道
   34   1        PWMA_CCER2 = 0x33; // 使能 CC3 CC4通道
   35   1        
   36   1        
   37   1        PWMA_CCR1H = (uint)(PWMB_CCA >> 8); // 设置CC1占空比时间 占空比2.5%
   38   1        PWMA_CCR1L = (uint)(PWMB_CCA); 
   39   1        
   40   1        PWMA_CCR2H = (uint)(PWMB_CCA >> 8); // 设置CC2占空比时间 占空比2.5%
   41   1        PWMA_CCR2L = (uint)(PWMB_CCA); 
   42   1        
   43   1        PWMA_CCR3H = (uint)(PWMB_CCA >> 8); // 设置CC3占空比时间 占空比2.5%
   44   1        PWMA_CCR3L = (uint)(PWMB_CCA); 
   45   1        
   46   1        PWMA_CCR4H = (uint)(PWMB_CCA >> 8); // 设置CC4占空比时间 占空比2.5%
   47   1        PWMA_CCR4L = (uint)(PWMB_CCA); 
   48   1        
   49   1      
   50   1        PWMA_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   51   1        PWMA_ARRL = (uint)(PWM_PERIOD); 
   52   1      
   53   1        PWMA_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   54   1        PWMA_BKR = 0x80;                    // 使能主输出
   55   1      
   56   1        PWMA_CR1 = 0x01;                    // 启动PWM定时器  
   57   1        
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  19:36:15  PAGE 2   

   58   1        
   59   1        //PWMB
   60   1        PWMB_PS = 0xAA;                   //PWMB:P00 P01 P02 P03
   61   1        
   62   1        PWMB_PSCRH = (uint)(PWM_PSC >> 8);
   63   1        PWMB_PSCRL = (uint)(PWM_PSC);         //23+1=24预分频
   64   1        
   65   1        
   66   1        PWMB_CCER1 = 0x00; // 写 CCMRx 前必须先清零 CCERx 关闭通道
   67   1        PWMB_CCER2 = 0x00; 
   68   1        
   69   1        PWMB_CCMR1 = 0x70; // 设置 CC1 为 PWM模式2
   70   1        PWMB_CCMR2 = 0x70; // 设置 CC2 为 PWM模式2
   71   1        PWMB_CCMR3 = 0x70; // 设置 CC3 为 PWM模式2
   72   1        PWMB_CCMR4 = 0x70; // 设置 CC4 为 PWM模式2
   73   1        PWMB_CCER1 = 0x33; // 使能 CC1 CC2通道
   74   1        PWMB_CCER2 = 0x33; // 使能 CC3 CC4通道
   75   1        
   76   1        
   77   1        PWMB_CCR5H = (uint)(PWMB_CCR5 >> 8); // 设置CC5占空比时间 占空比2.5%
   78   1        PWMB_CCR5L = (uint)(PWMB_CCR5); 
   79   1        
   80   1        PWMB_CCR6H = (uint)(PWMB_CCR6 >> 8); // 设置CC6占空比时间 占空比2.5%
   81   1        PWMB_CCR6L = (uint)(PWMB_CCR6); 
   82   1      
   83   1        PWMB_CCR7H = (uint)(PWMB_CCR7 >> 8); // 设置CC7占空比时间 占空比2.5%
   84   1        PWMB_CCR7L = (uint)(PWMB_CCR7); 
   85   1        
   86   1        PWMB_CCR8H = (uint)(PWMB_CCR8 >> 8); // 设置CC8占空比时间 占空比2.5%
   87   1        PWMB_CCR8L = (uint)(PWMB_CCR8); 
   88   1        
   89   1      
   90   1        PWMB_ARRH = (uint)(PWM_PERIOD >> 8); // 设置PWMA周期20毫秒
   91   1        PWMB_ARRL = (uint)(PWM_PERIOD); 
   92   1      
   93   1        PWMB_ENO = 0x55;                    // 使能 PWM1P 2p 端口输出
   94   1        PWMB_BKR = 0x80;                    // 使能主输出
   95   1      
   96   1        PWMB_CR1 = 0x01;                    // 启动PWM定时器    
   97   1      }
   98          
   99          
  100          //更新PWMB 5
  101          void Update_5(unsigned int Duty1)
  102          {
  103   1        PWMB_CCR5H = (uint)(Duty1 >> 8); // 设置CC5占空比时间 占空比2.5%
  104   1        PWMB_CCR5L = (uint)(Duty1); 
  105   1      }
  106          //更新PWMB 6
  107          void Update_6(unsigned int Duty2)
  108          {
  109   1        PWMB_CCR6H = (uint)(Duty2 >> 8); // 设置CC6占空比时间 占空比2.5%
  110   1        PWMB_CCR6L = (uint)(Duty2);   
  111   1      }
  112          //更新PWMB 7
  113          void Update_7(unsigned int Duty3)
  114          {
  115   1        PWMB_CCR7H = (uint)(Duty3 >> 8); // 设置CC7占空比时间 占空比2.5%
  116   1        PWMB_CCR7L = (uint)(Duty3);   
  117   1      }
  118          //更新PWMB 8
  119          void Update_8(unsigned int Duty4)
  120          {
  121   1        PWMB_CCR8H = (uint)(Duty4 >> 8); // 设置CC8占空比时间 占空比2.5%
  122   1        PWMB_CCR8L = (uint)(Duty4);   
  123   1      }
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  19:36:15  PAGE 3   

  124          
  125          /**************************************************************************
  126          函数功能：绝对值函数
  127          入口参数：int
  128          返回  值：unsigned int
  129          目    的：对PWM进行绝对值处理
  130          **************************************************************************/
  131          int myabs(int a)
  132          {        
  133   1          int temp;
  134   1          if(a<0)  temp=-a;  
  135   1          else temp=a;
  136   1          return temp;
  137   1      }
  138          
  139          /**************************************************************************
  140          函数功能：限制PWM赋值 
  141          入口参数：无
  142          返回  值：无
  143          **************************************************************************/
  144          void Xianfu_Pwm(void)
  145          {
  146   1         //===PWM满幅是100 限制在95
  147   1          if(Left_moto1<-950 ) Left_moto1=-950 ;
  148   1          if(Left_moto1>950 )  Left_moto1=950 ;
  149   1          if(Right_moto2<-950 ) Right_moto2=-950 ;
  150   1          if(Right_moto2>950 )  Right_moto2=950 ;
  151   1          if(Forwar_dmoto1<-950 ) Forwar_dmoto1=-950 ;
  152   1          if(Forwar_dmoto1>950 )  Forwar_dmoto1=950 ;
  153   1          if(Backward_moto2<-950 ) Backward_moto2=-950 ;
  154   1          if(Backward_moto2>950 )  Backward_moto2=950 ;
  155   1      }
  156          
  157          /**************************************************************************
  158          函数功能：检测异常关闭电机
  159          入口参数：检测异常参数
  160          返回  值：无
  161          **************************************************************************/
  162          //void Turn_Off(float angle)
  163          //{
  164          //    if(angle<-40||angle>40)  //电池电压低于11.1V关闭电机
  165          //    {                                    //===倾角大于40度关闭电机                                       
  166          //        moto1=0;
  167          //        moto2=0;
  168          //    }   
  169          //}
  170          
  171          /**************************************************************************
  172          函数功能：赋值给PWM寄存器
  173          入口参数：左轮PWM、右轮PWM
  174          返回  值：无
  175          **************************************************************************/
  176          
  177          void Set_LRPwm(int Left_moto1,int Right_moto2)    //更新左右风机占空比
  178          {
  179   1        
  180   1        
  181   1        if(Left_moto1<0)    
  182   1        AIN2=1,     AIN1=0;  //如果小于零就是反转  先变换电平  motol
  183   1        else
  184   1        AIN2=0,     AIN1=1;
  185   1        
  186   1        
  187   1        PWMA_CCR1H = (myabs(Left_moto1) >> 8);  
  188   1        PWMA_CCR1L = (myabs(Left_moto1));
  189   1      
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  19:36:15  PAGE 4   

  190   1        
  191   1        if(Right_moto2<0)   
  192   1        BIN1=0,     BIN2=1;
  193   1        
  194   1        else
  195   1        BIN1=1,     BIN2=0;
  196   1        
  197   1        PWMA_CCR2H = (myabs(Right_moto2)>> 8);  
  198   1        PWMA_CCR2L = (myabs(Right_moto2));
  199   1        
  200   1        
  201   1      }
  202          
  203          
  204          void Set_FBPwm(int Forwar_dmoto1,int Backward_moto2)    //更新前后风机占空比
  205          {
  206   1        
  207   1        
  208   1        if(Forwar_dmoto1<0)   
  209   1        CIN2=1,     CIN1=0;  //如果小于零就是反转  先变换电平  motol
  210   1        else
  211   1        CIN2=0,     CIN1=1;
  212   1        
  213   1        
  214   1        PWMA_CCR3H = (myabs(Forwar_dmoto1) >> 8);  
  215   1        PWMA_CCR3L = (myabs(Forwar_dmoto1));
  216   1      
  217   1        
  218   1        if(Forwar_dmoto1<0)   
  219   1        DIN1=0,     DIN2=1;
  220   1        
  221   1        else
  222   1        DIN1=1,     DIN2=0;
  223   1        
  224   1        PWMA_CCR4H = (myabs(Backward_moto2)>> 8);  
  225   1        PWMA_CCR4L = (myabs(Backward_moto2));
  226   1        
  227   1        
  228   1      }
  229          
  230          void Update_duty(uchar sw,int PWMR,int PWML)                    //更新占空比函数
  231          {
  232   1        
  233   1        if(!sw)
  234   1        {
  235   2          PWML = 0;
  236   2          PWMR = 0;
  237   2        }
  238   1        
  239   1        if(PWMR < 0)
  240   1        {
  241   2          PWMR = -PWMR;
  242   2          MotorR_Reverse();
*** WARNING C140 IN LINE 242 OF PWM\pwm_init.c: 'MotorR_Reverse' undefined; assuming 'extern int MotorR_Reverse()'
  243   2        }
  244   1        else 
  245   1          MotorR_Forward();
*** WARNING C140 IN LINE 245 OF PWM\pwm_init.c: 'MotorR_Forward' undefined; assuming 'extern int MotorR_Forward()'
  246   1          
  247   1        if(PWML < 0)
  248   1        {
  249   2          PWML = -PWML;
  250   2          MotorL_Reverse();
*** WARNING C140 IN LINE 250 OF PWM\pwm_init.c: 'MotorL_Reverse' undefined; assuming 'extern int MotorL_Reverse()'
  251   2        }
  252   1        else 
C251 COMPILER V5.60.0,  pwm_init                                                           04/08/23  19:36:15  PAGE 5   

  253   1          MotorL_Forward();
*** WARNING C140 IN LINE 253 OF PWM\pwm_init.c: 'MotorL_Forward' undefined; assuming 'extern int MotorL_Forward()'
  254   1          
  255   1        
  256   1        PWMA_CCR1H  = (uchar)(PWML >> 8);  
  257   1        PWMA_CCR1L = PWML;                //调整占空比
  258   1          
  259   1        PWMA_CCR2H = (uchar)(PWMR >> 8); 
  260   1        PWMA_CCR2L = PWMR;  
  261   1      }
  262          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       969     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        22     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        66     ------
End of Module Information.


C251 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)

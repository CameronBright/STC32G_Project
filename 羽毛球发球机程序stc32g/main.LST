C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE main.c XSMALL INTR2 WARNINGLEVEL(1) BROWSE IN
                    -CDIR(.\OLED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\Uart;.\Menu;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key) DEBUG TABS
                    -(2) 

stmt  level    source

    1          /*
    2          program versions : 2.3.1
    3          
    4          能控制电机正反转，用p值就已经可以完美循迹
    5          
    6          modification: 2023/8/1 14:06
    7          
    8          modifier: Cameron Bright
    9          
   10          */
   11          #include "timer.h"   //定时器
   12          #include "oled.h"   //OLED函数
   13          #include "GPIO.h"   //GPIO
   14          #include "pwm.h"      //pwm
   15          #include "Encoders.h"  //旋转编码器
   16          #include "key.h"    //按键
   17          #include "iic.h"    //i2C
   18          #include "Uart.h"   //串口
   19          #include "stdio.h"  //c标准库
   20          #include "Meun.h"   //显示屏菜单
   21          #include "motor.h"  //电机
   22          #include "ADC.h"    //ADC
   23          #include "LineFollower.h" //循迹模块
   24          #include "MPU6050.h"//mpu6050
   25          #include "MATH.H"   //数学运算模块
   26          
   27          //-------------------------------- system--------------------------------
   28          extern uint s_count;         //定时器计数
   29          extern uint delay_cnt;       //delay计数
   30          uint sys_led = 0;            //运行状态灯
   31          
   32          uint disp_delay;             //显示屏刷新延时计数
   33          uint motor_delay;            //电机函数刷新延时计数
   34          uint mpu6050_delay;          //mpu6050读取延时计数
   35          uint key_delay;              //案件延时刷新计数
   36          
   37          //----------------- motor(电机驱动和PID变量)--------------------------------
   38          extern int dutyL;            //左边电机驱动pwm 周期1000
   39          extern int dutyR;            //右
   40          
   41          uchar motor_sw = 1;//电机开关
   42          
   43          struct pid_parameter positionPID; //PID参数
   44          int err_kp, err_ki, err_kd;   //误差值
   45          char line_inaccuracy; //循迹模块偏移量
   46          char old_line_inaccuracy;//上一次循迹模块的便宜量
   47          char old_position;    //上一次的数据
   48          
   49          //------------------MPU6050-----------------------------------------------
   50          
   51          int Gyro_x, Gyro_y, Gyro_z;                        //三轴陀螺仪
   52          int Gyro_x_, Gyro_y_, Gyro_z_;                        //三轴陀螺仪滤波
   53          
   54          int Gyro_angle_x=0, Gyro_angle_y=0, Gyro_angle_z=0;
   55          int Acc_x, Acc_y, Acc_z;                           //三轴加速度
   56          int Temp;                                        //温度
   57          
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 2   

   58          int   xdata g_x=0,g_y=0,g_z=0;                   //陀螺仪矫正参数
   59          float xdata a_x=0,a_y=0;                         //角度矫正参数
   60          float data  AngleX=0, AngleY=0, AngleZ=0;          //四元数解算出的欧拉角
   61          float xdata Angle_gx=0, Angle_gy=0, Angle_gz=0;    //由角速度计算的角速率(角度制)
   62          float xdata Angle_ax=0, Angle_ay=0, Angle_az=0;    //由加速度计算的加速度(弧度制)
   63          
   64          uchar MPU6050_DATA[14];
   65          
   66          unsigned  int Angle_of_pitch = 0;
   67          unsigned  int Roll_Angle = 0;
   68          
   69          #define pi    3.14159265f                           
   70          #define Kp    0.8f                        
   71          #define Ki    0.001f                         
   72          #define halfT 0.004f  
   73          
   74          float idata q0=1,q1=0,q2=0,q3=0;   
   75          float idata exInt=0,eyInt=0,ezInt=0;  
   76          
   77          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az);
   78          
   79          //-----------------other--------------------------------------------------
   80          uchar txbuf[20]; //串口发送缓存
   81          
   82          uchar oled_showtext[25]; //oled显示字符串
   83          
   84          void Disp_refresh(void);  //数码管显示函数
   85          void Motor_control(void); //电机控制函数
   86          void MPU6050_Read(void);  //陀螺仪数据采集
   87          void Key_Proc(void);
   88          
   89          //*****************按键***********//
   90          
   91          unsigned char key_old = 0;
   92          unsigned char key_value = 0;
   93          unsigned char key_Down = 0;
   94          
   95          
   96          void main()
   97          {
   98   1        GPIO_init();//GPIO初始化
   99   1        OLED_Init();//oled初始化
  100   1        OLED_ColorTurn(0);//0正常显示，1 反色显示
  101   1        OLED_DisplayTurn(0);//0正常显示 1 屏幕翻转显示
  102   1        OLED_Clear();//oled清屏
  103   1        
  104   1        Timer1Init();//定时器初始化
  105   1        
  106   1        UartInit();//串口初始化 
  107   1        S1_S0=0;
  108   1        S1_S1=0;//串口1 选择P30 P31 
  109   1        
  110   1        P54RST=1;//复位初始化
  111   1        
  112   1        InitMPU6050(); //mpu6050初始化
  113   1        
  114   1        Motor_Init(); //电机初始化
  115   1        
  116   1        //PID参数
  117   1        positionPID.basicSpeed = 600;//基础运动速度
  118   1        positionPID.kp = 400;
  119   1        positionPID.ki = 0;
  120   1        positionPID.kd = 0;
  121   1        
  122   1        LED = 0;
  123   1      
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 3   

  124   1        while(1)
  125   1        { 
  126   2          Motor_control(); //电机控制函数
  127   2          Disp_refresh();  //显示屏刷新函数
  128   2          MPU6050_Read();  //陀螺仪数据采集
  129   2          Key_Proc();
  130   2          //sprintf(txbuf,"1:%04d 2:%04d 3:%04d\r\n",ADCP1,ADCP2,ADCP3);
  131   2          //Uart_String(txbuf); //串口
  132   2        }
  133   1      }
  134          //-----------------中断-----------------------------------
  135          void timer1() interrupt 3       //100us中断一次
  136          {
  137   1        if(++disp_delay == 100) disp_delay = 0;       //显示屏刷新时间
  138   1        if(++motor_delay == 10) motor_delay = 0;      //电机控制刷新时间
  139   1        if(++mpu6050_delay == 50) mpu6050_delay = 0;  //mpu6050执行刷新时间
  140   1        if(++key_delay == 100) key_delay = 0;        //按键扫描刷新时间
  141   1        
  142   1        if(++sys_led >= 5000)                         
  143   1        {
  144   2          LED ^= 1;
  145   2          sys_led = 0;
  146   2        }
  147   1        
  148   1        if(delay_cnt > 0) //延时函数
  149   1          delay_cnt--;
  150   1      
  151   1      } 
  152          
  153          //-----------------按键处理-----------------------------------
  154          void Key_Proc(void)
  155          {
  156   1        if(key_delay) return; //100ms扫描一次按键
  157   1        key_delay = 1;
  158   1        
  159   1        key_value = Key_Rvalue();//读取按键按下的编号
  160   1        key_Down = key_value & (key_old ^ key_value);                                   
  161   1        key_old = key_value;  
  162   1        
  163   1        switch(key_Down)
  164   1        {
  165   2          case 1:
  166   2              positionPID.kp++;
  167   2          break;
  168   2          case 2:
  169   2              positionPID.kp--;
  170   2          break;
  171   2          case 3:
  172   2              positionPID.kd++;
  173   2          break;
  174   2          case 4:
  175   2              positionPID.kd--;
  176   2          break;
  177   2        }
  178   1      }
  179          
  180          //-----------------显示屏函数-----------------------------------
  181          void Disp_refresh(void)
  182          {
  183   1        if(disp_delay) return; //10ms刷新一次屏幕
  184   1        disp_delay = 1;
  185   1        
  186   1        sprintf(oled_showtext,"line:%2d  ",line_inaccuracy);
  187   1        OLED_16x16(0,0,oled_showtext);
  188   1        
  189   1        sprintf(oled_showtext,"L:%3d,R%3d ",dutyL,dutyR);
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 4   

  190   1        OLED_16x16(0,2,oled_showtext);
  191   1        
  192   1        sprintf(oled_showtext,"basic:%3d ",positionPID.basicSpeed);
  193   1        OLED_16x16(0,4,oled_showtext);
  194   1      
  195   1      //  sprintf(oled_showtext,"X:%3d Y:%3d     ",Angle_ax,Angle_ax);
  196   1      //  OLED_Display_string_5x7(0,6,oled_showtext);
  197   1        
  198   1        sprintf(oled_showtext,"Z:%02d  ",(int)AngleZ);
  199   1        OLED_Display_string_5x7(0,7,oled_showtext);
  200   1        
  201   1        sprintf(oled_showtext,"p:%4d,d:%4d",(int)positionPID.kp,(int)positionPID.kd);
  202   1        OLED_Display_string_5x7(50,7,oled_showtext);
  203   1        
  204   1        //sprintf(txbuf,"X:%d Y:%d Z:%d\r\n",Gyro_x,Gyro_y,Gyro_z);
  205   1        //Uart_String(txbuf); //串口
  206   1        
  207   1      //  OLED_ShowNum(35,4,ADCP3,6);
  208   1      }
  209          
  210          
  211          //-------------陀螺仪控制函数----------------------------------------
  212          void MPU6050_Read(void)
  213          {
  214   1        if(mpu6050_delay) return; 
  215   1        mpu6050_delay = 1;
  216   1        
  217   1        Read_MPU6050(MPU6050_DATA);
  218   1        Acc_x = MPU6050_DATA[0]<<8|MPU6050_DATA[1]; //加速度
  219   1        Acc_y = MPU6050_DATA[2]<<8|MPU6050_DATA[3];
  220   1        Acc_z = MPU6050_DATA[4]<<8|MPU6050_DATA[5];
  221   1        
  222   1        Temp  = MPU6050_DATA[6]<<8|MPU6050_DATA[7]; //temperature
  223   1        
  224   1        Gyro_x = MPU6050_DATA[8]<<8|MPU6050_DATA[9]; //角速度
  225   1        Gyro_y = MPU6050_DATA[10]<<8|MPU6050_DATA[11]; 
  226   1        Gyro_z = MPU6050_DATA[12]<<8|MPU6050_DATA[13]; 
  227   1        
  228   1      //  if((Gyro_x == -1)||(Gyro_y == -1)||(Gyro_z == -1)||(Gyro_x == 0)||(Gyro_y == 0)||(Gyro_z == 0)) //高通
             -滤波
  229   1      //  {
  230   1      //    Gyro_x = Gyro_x_;
  231   1      //    Gyro_y = Gyro_y_;
  232   1      //    Gyro_z = Gyro_z_;
  233   1      //  }
  234   1      //  else 
  235   1      //  {
  236   1      //    Gyro_x_ = Gyro_x;
  237   1      //    Gyro_y_ = Gyro_y;
  238   1      //    Gyro_z_ = Gyro_z;
  239   1      //  }
  240   1        
  241   1        Angle_ax = Acc_x/8192.0; //偏移角
  242   1        Angle_ay = Acc_y/8192.0; 
  243   1        Angle_az = Acc_z/8192.0; 
  244   1        
  245   1        Angle_gx = Gyro_x/65.5; //
  246   1        Angle_gy = Gyro_y/65.5;
  247   1        Angle_gz = Gyro_z/65.5;
  248   1        
  249   1        IMUupdate(Angle_gx*0.0174533f,Angle_gy*0.0174533f,Angle_gz*0.0174533f,Angle_ax,Angle_ay,Angle_az);
  250   1        
  251   1        Angle_of_pitch = AngleX;
  252   1        Roll_Angle = AngleY;
  253   1        
  254   1        //==========串口查看波形=============
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 5   

  255   1      //  Uart_sendbyte(0x03);
  256   1      //  Uart_sendbyte(~0x03); 
  257   1      //  
  258   1      //  Uart_sendbyte((int)(Gyro_x));
  259   1      //  Uart_sendbyte((int)(Gyro_x)>>8);
  260   1      //                            
  261   1      //  Uart_sendbyte((int)(Gyro_y));
  262   1      //  Uart_sendbyte((int)(Gyro_y)>>8);
  263   1      //                            
  264   1      //  Uart_sendbyte((int)(Gyro_z));
  265   1      //  Uart_sendbyte((int)(Gyro_z)>>8);
  266   1      //  
  267   1      ////  Uart_sendbyte((int)(Angle_gx));
  268   1      ////  Uart_sendbyte((int)(Angle_gx)>>8);
  269   1      ////                            
  270   1      ////  Uart_sendbyte((int)(Angle_gy));
  271   1      ////  Uart_sendbyte((int)(Angle_gy)>>8);
  272   1      ////                            
  273   1      ////  Uart_sendbyte((int)(Angle_gz));
  274   1      ////  Uart_sendbyte((int)(Angle_gz)>>8);
  275   1      
  276   1      ////  Uart_sendbyte((int)(AngleX));
  277   1      ////  Uart_sendbyte((int)(AngleX)>>8);
  278   1      ////                            
  279   1      ////  Uart_sendbyte((int)(AngleY));
  280   1      ////  Uart_sendbyte((int)(AngleY)>>8);
  281   1      ////                            
  282   1      ////  Uart_sendbyte((int)(AngleZ));
  283   1      ////  Uart_sendbyte((int)(AngleZ)>>8);  
  284   1      //  
  285   1      //  Uart_sendbyte(~0x03);         
  286   1      //  Uart_sendbyte(0x03);
  287   1      }
  288          
  289          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az)
  290          {
  291   1        float data norm;
  292   1        float idata vx, vy, vz;
  293   1        float idata ex, ey, ez;
  294   1      
  295   1        norm = sqrt(ax*ax + ay*ay + az*az); //把加速度计的三维向量转成单维向量   
  296   1        ax = ax / norm;
  297   1        ay = ay / norm;
  298   1        az = az / norm;
  299   1      
  300   1          //  下面是把四元数换算成《方向余弦矩阵》中的第三列的三个元素。 
  301   1          //  根据余弦矩阵和欧拉角的定义，地理坐标系的重力向量，转到机体坐标系，正好是这三个元素
  302   1          //  所以这里的vx vy vz，其实就是当前的欧拉角（即四元数）的机体坐标参照系上，换算出来的
  303   1          //  重力单位向量。
  304   1        vx = 2*(q1*q3 - q0*q2);
  305   1        vy = 2*(q0*q1 + q2*q3);
  306   1        vz = q0*q0 - q1*q1 - q2*q2 + q3*q3 ;
  307   1      
  308   1        ex = (ay*vz - az*vy) ;
  309   1        ey = (az*vx - ax*vz) ;
  310   1        ez = (ax*vy - ay*vx) ;
  311   1      
  312   1        exInt = exInt + ex * Ki;
  313   1        eyInt = eyInt + ey * Ki;
  314   1        ezInt = ezInt + ez * Ki;
  315   1      
  316   1        gx = gx + Kp*ex + exInt;
  317   1        gy = gy + Kp*ey + eyInt;
  318   1        gz = gz + Kp*ez + ezInt;
  319   1      
  320   1        q0 = q0 + (-q1*gx - q2*gy - q3*gz) * halfT;
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 6   

  321   1        q1 = q1 + ( q0*gx + q2*gz - q3*gy) * halfT;
  322   1        q2 = q2 + ( q0*gy - q1*gz + q3*gx) * halfT;
  323   1        q3 = q3 + ( q0*gz + q1*gy - q2*gx) * halfT;
  324   1      
  325   1        norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
  326   1        q0 = q0 / norm;
  327   1        q1 = q1 / norm;
  328   1        q2 = q2 / norm;
  329   1        q3 = q3 / norm;
  330   1      
  331   1        AngleX = asin(2*(q0*q2 - q1*q3 )) * 57.2957795f; // 俯仰   换算成度
  332   1        AngleY = asin(2*(q0*q1 + q2*q3 )) * 57.2957795f; // 横滚
  333   1        AngleZ = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.2957795f; //滤波后的值
  334   1      }
  335          
  336          
  337          //-----------------电机控制函数-------------------------------------
  338          void Motor_control(void)
  339          {
  340   1        if(motor_delay) return; //延时
  341   1        motor_delay = 1;
  342   1        
  343   1        line_inaccuracy = ReadLine();//读取循线状态 1、-1、0
  344   1        
  345   1        if(line_inaccuracy > 2 || line_inaccuracy < -2)
  346   1        {
  347   2          if(line_inaccuracy == -3)//传感器远离地面时
  348   2            motor_sw = 0;
  349   2          else if(line_inaccuracy == 3) //所有传感器都在地面但没识别到线时
  350   2            line_inaccuracy = old_position;
  351   2        }
  352   1        else 
  353   1        {
  354   2          motor_sw = 1;//电机正常工作
  355   2          old_position = line_inaccuracy;//记录上一次的位置
  356   2        }
  357   1        
  358   1        err_kp = positionPID.kp * line_inaccuracy;     //循迹模块数据
  359   1        err_ki = positionPID.ki * line_inaccuracy;     //积分
  360   1        err_kd = positionPID.kd * old_line_inaccuracy; //微分
  361   1        
  362   1        if(line_inaccuracy)
  363   1        {
  364   2          dutyR = positionPID.basicSpeed + err_kp + err_kd; 
  365   2          dutyL = positionPID.basicSpeed - err_kp - err_kd;
  366   2        }
  367   1        else 
  368   1        {
  369   2          dutyR = positionPID.basicSpeed;
  370   2          dutyL = positionPID.basicSpeed;
  371   2        }
  372   1      
  373   1        
  374   1        Update_duty(motor_sw,dutyR,dutyL);//更新PWM输出
  375   1        old_line_inaccuracy = line_inaccuracy;
  376   1        
  377   1        
  378   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      2241     ------
  ecode size           =    ------     ------
  data size            =         4     ------
  idata size           =         8          4
  pdata size           =    ------     ------
C251 COMPILER V5.60.0,  main                                                               01/08/23  14:25:03  PAGE 7   

  xdata size           =        14     ------
  xdata-const size     =    ------     ------
  edata size           =       178         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       277     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

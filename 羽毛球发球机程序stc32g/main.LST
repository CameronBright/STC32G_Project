C251 COMPILER V5.60.0,  main                                                               24/07/23  21:10:44  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE main.c XSMALL INTR2 WARNINGLEVEL(1) BROWSE IN
                    -CDIR(.\OLED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\Uart;.\Menu;.\motor;.\ADC;.\LineFollower;.\MPU6050) DEBUG TABS(2) 

stmt  level    source

    1          #include "timer.h"   //定时器
    2          #include "oled.h"   //OLED函数
    3          #include "GPIO.h"   //GPIO
    4          #include "pwm.h"      //pwm
    5          #include "Encoders.h"  //旋转编码器
    6          #include "iic.h"
    7          #include "Uart.h"   //串口
    8          #include "stdio.h"
    9          #include "Meun.h"
   10          #include "motor.h"
   11          #include "ADC.h"
   12          #include "LineFollower.h" //循迹模块
   13          #include "stdio.h"
   14          #include "MPU6050.h"
   15          #include "MATH.H"
   16          
   17          //-------------------------------- system--------------------------------
   18          extern uint s_count;         //定时器计数
   19          extern uint delay_cnt;       //delay计数
   20          uint timer_delay = 0;        //1us tick
   21          
   22          uint disp_delay;             //显示屏刷新延时计数
   23          uint motor_delay;            //电机函数刷新延时计数
   24          
   25          //----------------- motor(电机驱动和PID变量)--------------------------------
   26          extern int dutyL;            //左边电机驱动pwm 周期1000
   27          extern int dutyR;            //右
   28          
   29          uchar motor_sw = 1;//电机开关
   30          
   31          struct pid_parameter positionPID; //PID参数
   32          char line_inaccuracy; //循迹模块偏移量
   33          char old_position;    //上一次的数据
   34          
   35          //------------------MPU6050-----------------------------------------------
   36          
   37          int Gyro_x, Gyro_y, Gyro_z;                        //三轴陀螺仪
   38          int Gyro_angle_x=0, Gyro_angle_y=0, Gyro_angle_z=0;
   39          int Acc_x, Acc_y, Acc_z;                           //三轴加速度
   40          int Temp;                                        //温度
   41          
   42          int   xdata g_x=0,g_y=0,g_z=0;                   //陀螺仪矫正参数
   43          float xdata a_x=0,a_y=0;                         //角度矫正参数
   44          float data  AngleX=0, AngleY=0, AngleZ=0;          //四元数解算出的欧拉角
   45          float xdata Angle_gx=0, Angle_gy=0, Angle_gz=0;    //由角速度计算的角速率(角度制)
   46          float xdata Angle_ax=0, Angle_ay=0, Angle_az=0;    //由加速度计算的加速度(弧度制)
   47          
   48          unsigned  int Angle_of_pitch = 0;
   49          unsigned  int Roll_Angle = 0;
   50          
   51          #define pi    3.14159265f                           
   52          #define Kp    0.8f                        
   53          #define Ki    0.001f                         
   54          #define halfT 0.004f  
   55          
   56          float idata q0=1,q1=0,q2=0,q3=0;   
   57          float idata exInt=0,eyInt=0,ezInt=0;  
   58          
C251 COMPILER V5.60.0,  main                                                               24/07/23  21:10:44  PAGE 2   

   59          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az);
   60          
   61          //-----------------other--------------------------------------------------
   62          uchar txbuf[20]; //串口发送缓存
   63          
   64          uchar oled_showtext[20]; //oled显示字符串
   65          
   66          void Disp_refresh(void);  //数码管显示函数
   67          void Motor_control(void); //电机控制函数
   68          
   69          void main()
   70          {
   71   1        GPIO_init();//GPIO初始化
   72   1        OLED_Init();//oled初始化
   73   1        OLED_ColorTurn(0);//0正常显示，1 反色显示
   74   1        OLED_DisplayTurn(1);//0正常显示 1 屏幕翻转显示
   75   1        OLED_Clear();//oled清屏
   76   1        
   77   1        Timer1Init();//定时器初始化
   78   1        UartInit();//串口初始化 
   79   1        S1_S0=0;S1_S1=0;//串口1 选择P30 P31 
   80   1        P54RST=1;//复位初始化
   81   1        
   82   1        
   83   1        Motor_Init();
   84   1        positionPID.basicSpeed = 400;
   85   1        
   86   1        while(1)
   87   1        { 
   88   2          //rotary_encoder();        //一直扫描旋转编码器函数 ,检测上升沿 下降沿    
   89   2          //Cancel_determine();      //按键取消和确定检测函数,计时方式
   90   2          //Memu();
   91   2          
   92   2          Motor_control();
   93   2          Disp_refresh(); 
   94   2          
   95   2          //sprintf(txbuf,"1:%04d 2:%04d 3:%04d\r\n",ADCP1,ADCP2,ADCP3);
   96   2          //Uart_String(txbuf); //串口
   97   2        }
   98   1      }
   99          void timer1() interrupt 3       //100us加一次
  100          {
  101   1        if(++disp_delay == 100) disp_delay = 0;
  102   1        if(++motor_delay == 10) motor_delay = 0;
  103   1        
  104   1        if(delay_cnt > 0) //延时函数
  105   1          delay_cnt--;
  106   1        
  107   1        if(++timer_delay > 10000)
  108   1        //Pwm_Fun();                 //pwm函数
  109   1        if(EC11_K==0)
  110   1        {
  111   2          long_short=1;          //编码器按下为0   
  112   2        }   
  113   1        if(long_short==1)         //进入计时的条件
  114   1        {
  115   2          s_count++;   
  116   2        }
  117   1      } 
  118          
  119          void Disp_refresh(void)
  120          {
  121   1        if(disp_delay) return; //10ms刷新一次屏幕
  122   1        disp_delay = 1;
  123   1        
  124   1        sprintf(oled_showtext,"%1d   ",line_inaccuracy);
C251 COMPILER V5.60.0,  main                                                               24/07/23  21:10:44  PAGE 3   

  125   1        OLED_16x16(0,0,oled_showtext);
  126   1        
  127   1        sprintf(oled_showtext,"%3d,%3d",dutyR,dutyL);
  128   1        OLED_16x16(0,2,oled_showtext);
  129   1        
  130   1        sprintf(oled_showtext,"%3d",positionPID.basicSpeed);
  131   1        OLED_16x16(0,4,oled_showtext);
  132   1      //  sprintf(oled_showtext,"P00:");
  133   1      //  OLED_16x16(0,2,oled_showtext);
  134   1      //  sprintf(oled_showtext,"P10:");
  135   1      //  OLED_16x16(0,4,oled_showtext);
  136   1      //  
  137   1      //  OLED_ShowNum(35,0,ADCP1,6);
  138   1      //  OLED_ShowNum(35,2,ADCP2,6);
  139   1      //  OLED_ShowNum(35,4,ADCP3,6); 
  140   1      }
  141          
  142          void Motor_control(void)
  143          {
  144   1        if(motor_delay) return;
  145   1        motor_delay = 1;
  146   1        
  147   1        line_inaccuracy = ReadLine();//读取循线状态 1、-1、0
  148   1        
  149   1        if(line_inaccuracy > 1 || line_inaccuracy < -1)
  150   1        {
  151   2          if(line_inaccuracy == -2)//传感器远离地面时
  152   2            motor_sw = 0;
  153   2          else if(line_inaccuracy == 2) //所有传感器都在地面但没识别到线时
  154   2            line_inaccuracy = old_position;
  155   2        }
  156   1        else 
  157   1        {
  158   2          motor_sw = 1;//正常
  159   2          old_position = line_inaccuracy;//记录上一次的位置
  160   2        }
  161   1          
  162   1        dutyR = positionPID.basicSpeed + line_inaccuracy*600; //右偏左偏
  163   1        dutyL = positionPID.basicSpeed - line_inaccuracy*600;
  164   1        
  165   1        Motor_FRcontrol(dutyR,dutyL);//pwm值小于0就反转，大于0正转
  166   1        
  167   1        Update_duty(motor_sw);//更新PWM输出
  168   1      }
  169          
  170          void IMUupdate(float gx, float gy, float gz, float ax, float ay, float az)
  171          {
  172   1        float data norm;
  173   1        float idata vx, vy, vz;
  174   1        float idata ex, ey, ez;
  175   1      
  176   1        norm = sqrt(ax*ax + ay*ay + az*az); //把加速度计的三维向量转成单维向量   
  177   1        ax = ax / norm;
  178   1        ay = ay / norm;
  179   1        az = az / norm;
  180   1      
  181   1          //  下面是把四元数换算成《方向余弦矩阵》中的第三列的三个元素。 
  182   1          //  根据余弦矩阵和欧拉角的定义，地理坐标系的重力向量，转到机体坐标系，正好是这三个元素
  183   1          //  所以这里的vx vy vz，其实就是当前的欧拉角（即四元数）的机体坐标参照系上，换算出来的
  184   1          //  重力单位向量。
  185   1        vx = 2*(q1*q3 - q0*q2);
  186   1        vy = 2*(q0*q1 + q2*q3);
  187   1        vz = q0*q0 - q1*q1 - q2*q2 + q3*q3 ;
  188   1      
  189   1        ex = (ay*vz - az*vy) ;
  190   1        ey = (az*vx - ax*vz) ;
C251 COMPILER V5.60.0,  main                                                               24/07/23  21:10:44  PAGE 4   

  191   1        ez = (ax*vy - ay*vx) ;
  192   1      
  193   1        exInt = exInt + ex * Ki;
  194   1        eyInt = eyInt + ey * Ki;
  195   1        ezInt = ezInt + ez * Ki;
  196   1      
  197   1        gx = gx + Kp*ex + exInt;
  198   1        gy = gy + Kp*ey + eyInt;
  199   1        gz = gz + Kp*ez + ezInt;
  200   1      
  201   1        q0 = q0 + (-q1*gx - q2*gy - q3*gz) * halfT;
  202   1        q1 = q1 + ( q0*gx + q2*gz - q3*gy) * halfT;
  203   1        q2 = q2 + ( q0*gy - q1*gz + q3*gx) * halfT;
  204   1        q3 = q3 + ( q0*gz + q1*gy - q2*gx) * halfT;
  205   1      
  206   1        norm = sqrt(q0*q0 + q1*q1 + q2*q2 + q3*q3);
  207   1        q0 = q0 / norm;
  208   1        q1 = q1 / norm;
  209   1        q2 = q2 / norm;
  210   1        q3 = q3 / norm;
  211   1      
  212   1        AngleX = asin(2*(q0*q2 - q1*q3 )) * 57.2957795f; // 俯仰   换算成度
  213   1        AngleY = asin(2*(q0*q1 + q2*q3 )) * 57.2957795f; // 横滚
  214   1        AngleZ = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.2957795f;
  215   1      }
  216          
  217          //  IT0=0;  //中断0    IT0=0;上升沿和下降沿触发   IT0=1 下降沿触发
  218          //  EX0=1;  //使能中断0
  219          //  IT1=0;  //中断0    IT0=0;上升沿和下降沿触发   IT0=1 下降沿触发
  220          //  EX1=1;  //使能中断0
  221          
  222          //add_loseit EC11_OLD_A;
  223          //add_loseit EC11_UP_A;
  224          //add_loseit EC11_DOWN_A
  225          //add_loseit EC11_OLD_add_lose;
  226          //void init0_Isr() interrupt 0
  227          //{
  228          //    IE1=0;
  229          //    EC11_UP_A=~EC11_A&(EC11_OLD_A^EC11_A);
  230          //    EC11_DOWN_A=EC11_A&(EC11_OLD_A^EC11_A)
  231          //    EC11_OLD_A=EC11_A;
  232          //    if(EC11_UP_A)
  233          //    {
  234          //      if(EC11_add_lose)
  235          //      {
  236          //        flag=1;
  237          //          t+=0.01;
  238          //      
  239          //      }else{
  240          //        t-=0.01;
  241          //      }
  242          //    }
  243          //    if(EC11_DOWN_A)
  244          //    {
  245          //      if(EC11_add_lose==0)
  246          //      {
  247          //        flag=1;
  248          //          t-=0.01;
  249          //      
  250          //      }else{
  251          //        flag=1;
  252          //          t-=0.01;
  253          //      }
  254          //    }
  255          //}
  256          //void init1_Isr() interrupt 2
C251 COMPILER V5.60.0,  main                                                               24/07/23  21:10:44  PAGE 5   

  257          //{
  258          //  IE0=0;
  259          //}
  260          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1511     ------
  ecode size           =    ------     ------
  data size            =         4     ------
  idata size           =         8          4
  pdata size           =    ------     ------
  xdata size           =        14     ------
  xdata-const size     =    ------     ------
  edata size           =       130         20
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       226     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

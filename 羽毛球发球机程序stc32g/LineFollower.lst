C251 COMPILER V5.60.0,  LineFollower                                                       04/08/23  19:36:16  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE LineFollower
OBJECT MODULE PLACED IN LineFollower.obj
COMPILER INVOKED BY: D:\Software\Worksoftware\Keil5_C251\C251\BIN\C251.EXE LineFollower\LineFollower.c XSMALL INTR2 WARN
                    -INGLEVEL(1) BROWSE INCDIR(.\OLED;.\timer;.\GPIO;.\PWM;.\Encoders;.\iic;.\motor;.\ADC;.\LineFollower;.\MPU6050;.\Key;.\Wa
                    -ve;.\Uart;.\SYN6288) DEBUG PRINT(.\LineFollower.lst) TABS(2) OBJECT(LineFollower.obj) 

stmt  level    source

    1          #include "LineFollower.h"
    2          #include "Wave.h"
    3          
    4          
    5          
    6          //循迹线标志位
    7          unsigned char count = 0;  
    8          extern unsigned char Wave_flag;
    9          extern unsigned char T_S_B;
   10          extern unsigned char flag;
   11          extern unsigned char flag_count;
   12          extern unsigned char Tracking_value;
   13          extern char line_inaccuracy;
   14          extern void Motor_control();
   15          
   16          
   17          uchar ReadLine(void) //往左边偏的时候输出1 右边偏输出-1 踩在线上输出0
   18          { 
   19   1        uchar read_value = 0;
   20   1        char return_value = 0;
   21   1        
   22   1      
   23   1          if(det_L == 1)
   24   1            read_value |= 0x10; //置1
   25   1          else 
   26   1            read_value &= ~0x10;
   27   1      
   28   1          if(det_CL == 1)
   29   1            read_value |= 0x08;
   30   1          else 
   31   1            read_value &= ~0x08;
   32   1          
   33   1          if(det_C == 1)
   34   1            read_value |= 0x04;
   35   1          else 
   36   1            read_value &= ~0x04;
   37   1          
   38   1          if(det_CR == 1)
   39   1            read_value |= 0x02;
   40   1          else 
   41   1            read_value &= ~0x02;
   42   1          
   43   1          if(det_R == 1)
   44   1            read_value |= 0x01;
   45   1          else 
   46   1            read_value &= ~0x01;
   47   1          
   48   1          
   49   1          switch(read_value)
   50   1          {
   51   2            case 0x04:            //正常行驶
   52   2              return_value = 0;
   53   2              break;
   54   2            case 0x08:           //往右边偏一点点
   55   2              return_value = 1;
   56   2              break;
   57   2            case 0x02:           //往左边偏一点点
C251 COMPILER V5.60.0,  LineFollower                                                       04/08/23  19:36:16  PAGE 2   

   58   2              return_value = -1;
   59   2              break;
   60   2            case 0x0C:           //往右边偏一点点
   61   2              return_value = 1;
   62   2              break;
   63   2            case 0x06:           //往左边偏一点点
   64   2              return_value = -1;
   65   2              break;
   66   2            case 0x10:
   67   2              return_value = 2; //往右偏较大角度
   68   2              break;
   69   2            case 0x01:
   70   2              return_value = -2;//往坐偏较大角度
   71   2              break;
   72   2            case 0x18:
   73   2              return_value = 2; //往右偏较大角度
   74   2              break;
   75   2            case 0x03:
   76   2              return_value = -2;//往坐偏较大角度
   77   2              break;  
   78   2            case 0x1F:
   79   2              return_value = -3;//宝马离开地面返回  ‘-3‘
   80   2            break;
   81   2            
   82   2            default:
   83   2              return_value = 3;//没识别到黑线返回 ‘3‘
   84   2            break;
   85   2          } 
   86   1        return return_value;
   87   1      }
   88          
   89          //巡线处理函数
   90          void ReadLine_proc(void)
   91          {
   92   1        if(T_S_B == 1)
   93   1        {
   94   2          T_S_B_1_ReadLine();
   95   2        }
   96   1        if(T_S_B == 2)
   97   1        {
   98   2          T_S_B_2_ReadLine();
   99   2        }
  100   1      }
  101          
  102          //基础部分
  103          
  104          //功能2
  105          void T_S_B_1_ReadLine()
  106          {
  107   1        Motor_control();
  108   1        if(line_inaccuracy == -3 ||line_inaccuracy == -2)   //判断5路都在黑线上
  109   1        {
  110   2          flag = 1;
  111   2        }
  112   1        if(Tracking_value == 4)  //循迹1圈 循迹次数标志位+4  
  113   1        {
  114   2          Tracking_value = 0;   //循迹完1圈 标志位置0
  115   2          flag = 0;             
  116   2          T_S_B = 0;            //状态恢复
  117   2        }   
  118   1      }
  119          
  120          
  121          
  122          //功能3
  123          void T_S_B_2_ReadLine(void)
C251 COMPILER V5.60.0,  LineFollower                                                       04/08/23  19:36:16  PAGE 3   

  124          {
  125   1      
  126   1          Motor_control();
  127   1          if(line_inaccuracy == -3 || line_inaccuracy == -2)   //判断5路都在黑线上
  128   1          {
  129   2            flag = 1;
  130   2            if(Tracking_value == 6)  //循迹1圈 标志位+4
  131   2            {
  132   3              Tracking_value = 0;   //循迹完1圈 标志位置0
  133   3              flag = 0;             
  134   3              T_S_B = 0;            //状态恢复
  135   3            }  
  136   2          } 
  137   1          if(Tracking_value == 4)  
  138   1          {
  139   2      //      moter_wheel();
  140   2          }
  141   1      }
  142          
  143            //左拐函数  输入左右PWM
  144          void moter_wheel(int left_moto,int right_moto)//用与循迹a、b点转弯  左右风速
  145          {
  146   1          bit Turn_left_flage = 0;
  147   1        
  148   1          Turn_left_flage = 1;
  149   1      
  150   1          //重新开启左边电机和右边电机
  151   1          Set_LRPwm(left_moto,right_moto);    //问题一 如何左转不会被循迹控制  左转完成后如何恢复循迹控制
  152   1        
  153   1          
  154   1          
  155   1          if(line_inaccuracy == 2)//左边的红外碰到碰到最近的循迹
  156   1          {
  157   2            Turn_left_flage = 0;
  158   2      //      Motor_control(）//恢复循迹 直到碰到下个AB
  159   2          }
  160   1          
  161   1          
  162   1          
  163   1      }
  164          
  165          
  166          
  167          
  168          ////发挥部分
  169          ////功能1
  170          
  171          void obstacle_avoidance()
  172          {
  173   1        Motor_control();
  174   1        if(Wave_ultrasonic() > 40)
  175   1        {
  176   2          
  177   2        }
  178   1      }
  179          
  180          
  181          ////功能2
  182          
  183          
  184          
  185          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       346     ------
C251 COMPILER V5.60.0,  LineFollower                                                       04/08/23  19:36:16  PAGE 4   

  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =         1     ------
  bit size             =    ------          1
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =         5     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
